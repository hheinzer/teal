#!/usr/bin/env python3

from argparse import ArgumentParser, BooleanOptionalAction as Boolean
import os
from pathlib import Path
import subprocess

import darkdetect
import h5py
import matplotlib.pyplot as plt
from mpi4py import MPI
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import pyvista as pv


def set_global_theme():
    if darkdetect.theme() == "Dark":
        pv.global_theme = pv.themes.DarkTheme()
    else:
        pv.global_theme = pv.themes.DocumentTheme()


def parse_args():
    parser = ArgumentParser(description="Visualize an unstructured grid")
    parser.add_argument("fnames", nargs="+", help="Input file(s)")
    parser.add_argument("-f", "--field", help="Field to plot")
    parser.add_argument("-l", "--list", action=Boolean, help="List all plottable fields")
    parser.add_argument("--points", action=Boolean, help="Interpolate to points")
    parser.add_argument("--explode", action=Boolean, help="Explode cells")
    parser.add_argument("--edges", action=Boolean, help="Show edges")
    parser.add_argument("--clip", action=Boolean, help="Add clip plane")
    parser.add_argument("--crinkle", action=Boolean, help="Crinkle clip")
    parser.add_argument("--line", action=Boolean, help="Plot over line")
    parser.add_argument("--video", action=Boolean, help="Create a video")
    parser.add_argument("--vmin", type=float, help="Minimum field value")
    parser.add_argument("--vmax", type=float, help="Maximum field value")
    parser.add_argument("--cmap", default="coolwarm", help="Colormap")
    return parser.parse_args()


def read_mesh(fname):
    if not fname.endswith("_mesh.h5"):
        return pv.read(fname)

    with h5py.File(fname, "r") as file:
        coords = file["nodes/coord"][...]
        node_offs = file["cells/node/off"][...]
        node_idxs = file["cells/node/idx"][...]
        types = file["cells/type"][...]
        fields = {
            name: field[...]
            for name, field in file["cells/"].items()
            if isinstance(field, h5py.Dataset) and field.shape[0] == types.shape[0]
        }

    cells = []
    for beg, end in zip(node_offs, node_offs[1:]):
        cells.append(end - beg)
        cells.extend(node_idxs[beg:end])

    mesh = pv.UnstructuredGrid(cells, types, coords)
    for name, field in fields.items():
        mesh[name] = field

    return mesh


def prepare_mesh(mesh, args):
    if args.field:
        mesh.set_active_scalars(args.field)

    if args.points:
        mesh = mesh.cell_data_to_point_data()

    if args.explode:
        mesh = mesh.explode()
    else:
        vol_types = np.array([10, 12, 13, 14], dtype=np.uint8)
        keep = np.where(np.isin(mesh.celltypes, vol_types))[0]
        mesh = mesh.extract_cells(keep).clean()

    return mesh


def plot_line(mesh, args, fname=None):
    xmin = mesh.points.min(axis=0)[0]
    xmax = mesh.points.max(axis=0)[0]
    mean = mesh.points.mean(axis=0)

    pointa = (xmin, mean[1], mean[2])
    pointb = (xmax, mean[1], mean[2])
    sample = mesh.sample_over_line(pointa, pointb, resolution=1000)

    fig, ax = plt.subplots()

    for name in sample.array_names:
        if args.field not in name:
            continue

        zorder = 1 if "exact" in name else 2
        data = sample[name]

        if data.ndim == 1:
            ax.plot(sample.points[:, 0], data, label=name, zorder=zorder)
        elif data.ndim == 2:
            if data.shape[1] == 3:
                for i, dim in enumerate([" x", " y", " z"]):
                    ax.plot(sample.points[:, 0], data[:, i], label=name + dim, zorder=zorder)
            elif data.shape[1] == 9:
                for i, dim in enumerate(
                    [" xx", " xy", " xz", " yx", " yy", " yz", " zx", " zy", " zz"]
                ):
                    ax.plot(sample.points[:, 0], data[:, i], label=name + dim, zorder=zorder)
        else:
            norm = np.linalg.norm(data, axis=-1)
            ax.plot(sample.points[:, 0], norm, label=name + " norm", zorder=zorder)

    ax.set_ylim(args.vmin, args.vmax)

    ax.legend()
    ax.set_xlabel("x-axis")
    ax.set_ylabel(args.field)

    fig.tight_layout()
    if fname is None:
        plt.show()
    elif args.video:
        fname = Path(fname).with_suffix(".png")
        fig.savefig(fname, dpi=600, bbox_inches="tight")
    else:
        fname = Path(fname).with_suffix(".pdf")
        fig.savefig(fname, dpi=600, bbox_inches="tight")
    plt.close()


def save_screenshot(img, bounds, vmin, vmax, args, fname):
    fig, ax = plt.subplots()

    xmin, xmax, ymin, ymax, _, _ = bounds
    im = ax.imshow(
        img,
        cmap=args.cmap,
        extent=(xmin, xmax, ymin, ymax),
        vmin=vmin,
        vmax=vmax,
        interpolation="none",
    )

    div = make_axes_locatable(ax)
    cax = div.append_axes("right", size=0.15, pad=0.1)
    cb = plt.colorbar(im, cax=cax)
    cb.set_label(args.field)

    ax.set_xlabel("x-axis")
    ax.set_ylabel("y-axis")

    fig.tight_layout()
    if args.video:
        fname = Path(fname).with_suffix(".png")
        fig.savefig(fname, dpi=600, bbox_inches="tight")
    else:
        fname = Path(fname).with_suffix(".pdf")
        fig.savefig(fname, dpi=600, bbox_inches="tight")
    plt.close()


def get_data_range(mesh, args):
    if args.field is None:
        return None, None

    data = mesh[args.field]
    if data.ndim == 1:
        vmin, vmax = data.min(), data.max()
    else:
        norm = np.linalg.norm(data, axis=1)
        vmin, vmax = norm.min(), norm.max()

    if args.vmin is not None:
        vmin = args.vmin
    if args.vmax is not None:
        vmax = args.vmax

    return (vmin, vmax)


def plot_field(mesh, args, fname=None):
    if fname is None:
        plotter = pv.Plotter(lighting="three lights")
    else:
        plotter = pv.Plotter(lighting="three lights", off_screen=True, window_size=[4000, 4000])

    if args.explode:
        plotter.disable_ssao()

    vmin, vmax = get_data_range(mesh, args)
    kwargs = dict(
        show_edges=args.edges,
        clim=(vmin, vmax) if vmin is not None and vmax is not None else None,
        cmap=args.cmap,
        show_scalar_bar=fname is None,
    )
    if args.clip:
        plotter.add_mesh_clip_plane(mesh, crinkle=args.crinkle, **kwargs)
    else:
        plotter.add_mesh(mesh, **kwargs)

    if fname is None:
        plotter.show_bounds(xtitle="x-axis", ytitle="y-axis", ztitle="z-axis")
        plotter.show()
    else:
        plotter.camera.tight(view="xy")
        img = plotter.screenshot(None, transparent_background=True, return_img=True)
        plotter.close()
        save_screenshot(img, mesh.bounds, vmin, vmax, args, fname)


def make_video(args):
    prefix = "_".join(args.fnames[0].split("_")[:-1])
    fnames = [str(Path(fname).with_suffix(".png")) for fname in args.fnames]
    command = [
        "ffmpeg",
        "-y",
        "-framerate",
        "20",
        "-i",
        f"{prefix}_%05d.png",
        "-pix_fmt",
        "yuv420p",
        "-vf",
        "pad=ceil(iw/2)*2:ceil(ih/2)*2",
        "-r",
        "60",
        f"{prefix}_{args.field}.mp4",
    ]
    subprocess.run(command)

    for fname in fnames:
        os.remove(fname)


def make_pdf(args):
    prefix = "_".join(args.fnames[0].split("_")[:-1])
    fnames = [str(Path(fname).with_suffix(".pdf")) for fname in args.fnames]
    command = [
        "pdfunite",
        *fnames,
        f"{prefix}_{args.field}.pdf",
    ]
    subprocess.run(command)

    for fname in fnames:
        os.remove(fname)


def plot_frames(args):
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    size = comm.Get_size()

    for fname in args.fnames[rank::size]:
        mesh = read_mesh(fname)
        mesh = prepare_mesh(mesh, args)
        if args.line and args.field:
            plot_line(mesh, args, fname)
        else:
            plot_field(mesh, args, fname)
        print(rank, fname)

    comm.Barrier()
    if rank == 0:
        if args.video:
            make_video(args)
        else:
            make_pdf(args)


def main():
    set_global_theme()
    args = parse_args()
    fnames = args.fnames

    if args.list:
        mesh = read_mesh(fnames[0])
        print("\n".join(mesh.array_names))
        return

    if len(fnames) == 1:
        mesh = read_mesh(fnames[0])
        mesh = prepare_mesh(mesh, args)
        if args.line and args.field:
            plot_line(mesh, args)
        else:
            plot_field(mesh, args)
        return

    if args.field:
        plot_frames(args)


if __name__ == "__main__":
    main()
